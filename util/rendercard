#!/usr/bin/python3
#+
# This script takes an XML card template from standard input and renders the card
# image in PNG format to standard output.
#
# The XML template looks like this:
#
#     <carddef>
#         label
#         label ...
#     </carddef>
#
# where each label looks like
#
#     <label slot="slot">content</label>
#
# where the slot specifies where to position the label (as below), and the content is a
# mix of straight text and the following special items:
#
#     <angle/>
#         An angle symbol is drawn.
#     <button>titletext</button>
#         The titletext is rendered inline with the rest of the text with a box around it.
#     <darrow/>
#         A double-headed-arrow character is drawn.
#     <Delta/>
#         A capital-delta character is drawn.
#     <div/>
#         A divide symbol is drawn.
#     <lambda/>
#         A lambda character is drawn.
#     <mul/>
#         A multiply symbol is drawn.
#     <noverr/>
#         A letter n and letter r are drawn vertically aligned.
#     <rarrow/>
#         A right-arrow character is drawn.
#     <sigma/>
#         A sigma character is drawn.
#     <sub>subscripttext</sub>
#         The subscripttext is rendered lowered with a smaller font.
#     <sup>superscripttext</sup>
#         The superscripttext is rendered raised with a smaller font.
#     <theta/>
#         A theta character is drawn.
#     <xbar/>
#         An x with a bar over it is drawn.
#
# The label slots must be from the following:
#
#     titleleft -- second row, left-aligned
#     titleright -- second row, right-aligned
#     aprime, bprime, cprime, dprime, eprime -- third row, five cells
#     primecenter -- third row, centred in single full-width cell
#     a, b, c, d, e -- fourth row, five cells
#     basecenter -- fourth row, centred in single full-width cell
#
# Note that the ones that treat a row as a single cell are incompatible
# with the ones that divide it into multiple cells.
#
# Copyright 2011 Lawrence D'Oliveiro <ldo@geek-central.gen.nz>.
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#-

from functools import \
    reduce
import sys
import io
import subprocess
import xml.parsers.expat as expat
import xml.sax.saxutils as saxutils

#+
# Useful stuff
#-

def psstring(data) :
    """returns a PostScript string literal that evaluates to data."""
    data = str(data)
    result = ""
    for i in range(0, len(data)) :
        ch = data[i]
        if ch == "(" or ch == ")" or ch == "\\" :
            ch = "\\" + ch
        # everything else can remain as is
        #end if
        result += ch
    #end for
    return "(" + result + ")"
#end psstring

def mm(dist) :
    """returns the equivalent in points to dist in millimetres."""
    return dist * 72 / 25.4
#end mm

#+
# Card template
#-

label_slots = \
    {
    # key is slot name, value is dict with keys:
    #     row -- row number [2 .. 4] (top row reserved for fixed text)
    #     cell -- cell number [1 .. 5] if row is divided into cells, or 0 if entire row is one cell
    #     align -- alignment of label text within cell (actually ignored for multiple cells per row)
        "titleleft" : {"row" : 2, "cell" : 0, "align" : "left"},
        "titleright" : {"row" : 2, "cell" : 0, "align" : "right"},
        "aprime" : {"row" : 3, "cell" : 1, "align" : "center"},
        "bprime" : {"row" : 3, "cell" : 2, "align" : "center"},
        "cprime" : {"row" : 3, "cell" : 3, "align" : "center"},
        "dprime" : {"row" : 3, "cell" : 4, "align" : "center"},
        "eprime" : {"row" : 3, "cell" : 5, "align" : "center"},
        "primecenter" : {"row" : 3, "cell" : 0, "align" : "center"},
        "basecenter" : {"row" : 4, "cell" : 0, "align" : "center"},
        "baseleft" : {"row" : 4, "cell" : 0, "align" : "left"},
        "baseright" : {"row" : 4, "cell" : 0, "align" : "right"},
        "a" : {"row" : 4, "cell" : 1, "align" : "center"},
        "b" : {"row" : 4, "cell" : 2, "align" : "center"},
        "c" : {"row" : 4, "cell" : 3, "align" : "center"},
        "d" : {"row" : 4, "cell" : 4, "align" : "center"},
        "e" : {"row" : 4, "cell" : 5, "align" : "center"},
    }

# classes representing label content:
class cdata :
    """straight text."""

    def __init__(self, text) :
        self.text = text
    #end __init__

    def __repr__(self) :
        return repr("<cdata>%s</cdata>" % self.text)
    #end __repr__

#end cdata

class taggedtext :
    """common superclass for various tag types."""

    def __init__(self, tag, text) :
        self.tag = tag
        self.text = text
    #end __init__

    def __repr__(self) :
        return repr("<%s>%s</%s>" % (self.tag, self.text, self.tag))
    #end __repr__

#end taggedtext

class button(taggedtext) :
    """an inline button label."""

    def __init__(self, text) :
        super().__init__("button", text)
    #end __init__

#end button

class subscript(taggedtext) :
    """an inline subscript label."""

    def __init__(self, text) :
        super().__init__("sub", text)
    #end __init__

#end subscript

class superscript(taggedtext) :
    """an inline superscript label."""

    def __init__(self, text) :
        super().__init__("sup", text)
    #end __init__

#end superscript

class noverr(taggedtext) :

    def __init__(self) :
        super().__init__("noverr", "")
    #end __init__

    def __repr__(self) :
        return "<xbar/>"
    #end __repr__

#end noverr

class xbar(taggedtext) :

    def __init__(self) :
        super().__init__("xbar", "")
    #end __init__

    def __repr__(self) :
        return "<xbar/>"
    #end __repr__

#end xbar

def defsymbol(name, psstr) :

    class newsymbol(taggedtext) :

        def __init__(self) :
            super().__init__(name, "")
        #end __init__

    #end newsymbol

#begin defsymbol
    newsymbol.__name__ = name
    newsymbol.psstr = psstr
    return newsymbol
#end defsymbol

symbols = \
    { # based on symbol font
        "angle" : defsymbol("angle", "(\\320)"),
        "darrow" : defsymbol("darrow", "(\\253)"),
        "Delta" : defsymbol("Delta", "(\\104)"),
        "div": defsymbol("div", "(\\270)"),
        "epsilon": defsymbol("epsilon", "(\\145)"),
        "lambda" : defsymbol("lambda", "(\\154)"),
        "mul": defsymbol("mul", "(\\264)"),
        "rarrow" : defsymbol("rarrow", "(\\256)"),
        "sigma" : defsymbol("sigma", "(\\163)"),
        "theta" : defsymbol("theta", "(\\161)"),
    }

fontname = "Helvetica"
symbolfontname = "Symbol"
basefontsize = 7.0
subsupscale = 0.8
suboffset = -0.2
superoffset = 0.6

def parse_template(input) :

    parse_state = {"nest" : 0, "main_seen" : False, "save_content" : [], "content" : None}
    result = [None] * 4

    def require_attrs(tag, attrs, attrnames) :
        """ensures that attrs has values for all keys listed in attrnames."""
        if not reduce(lambda a, b : a and b, (name in attrs for name in attrnames), True) :
            raise RuntimeError("missing required attributes for \"%s\"" % tag)
        #end if
    #end require_attrs

    def handle_label_def(tag, attrs) :
        require_attrs(tag, attrs, ("slot",))
        slotname = attrs["slot"]
        if slotname not in label_slots :
            raise RuntimeError("invalid slot name \"%s\"" % slotname)
        #end if
        slot = label_slots[slotname]
        if result[slot["row"] - 1] == None :
            result[slot["row"] - 1] = {"nrcells" : None}
        #end if
        row = result[slot["row"] - 1]
        if row["nrcells"] != None :
            if (row["nrcells"] == 1) != (slot["cell"] == 0) :
                raise RuntimeError("slot %s incompatible with previously-specified slots" % slotname)
            #end if
        else :
            row["nrcells"] = [1, 5][slot["cell"] != 0]
        #end if
        if slot["cell"] != 0 :
            key = slot["cell"]
        else :
            key = slot["align"]
        #end if
        if key in row :
            raise RuntimeError("already filled %s slot in row %d" % (key, slot["row"]))
        #end if
        parse_state["cur_label"] = {"content" : []}
        row[key] = parse_state["cur_label"]
    #end handle_label_def

    def handle_label_end(tag) :
        parse_state["cur_label"]["content"].append(cdata("".join(parse_state["content"])))
    #end handle_label_end

    def handle_common_tag_start(tag, attrs) :
        # presence of handler just to indicate tag is valid
        pass
    #end handle_common_def

    def handle_common_end(tagclass) :
        parse_state["cur_label"]["content"].append(tagclass("".join(parse_state["content"])))
    #end handle_common_end

    def handle_button_end(tag) :
        handle_common_end(button)
    #end handle_button_end

    def handle_subscript_end(tag) :
        handle_common_end(subscript)
    #end handle_subscript_end

    def handle_superscript_end(tag) :
        handle_common_end(superscript)
    #end handle_superscript_end

    def make_symbol_def(tagclass) :
        def handle_def(tag) :
            parse_state["cur_label"]["content"].append(tagclass())
        #end handle_def
        return handle_def
    #end make_symbol_def

    element_handlers = \
        {
            1 :
                {
                    "label" : handle_label_def,
                    "/label" : handle_label_end,
                },
            2 :
                {
                    "button" : handle_common_tag_start,
                    "/button" : handle_button_end,
                     "sub" : handle_common_tag_start,
                    "/sub" : handle_subscript_end,
                    "sup" : handle_common_tag_start,
                    "/sup" : handle_superscript_end,
                }
        }
    for symbol in symbols.values() :
        element_handlers[2][symbol.__name__] = handle_common_tag_start
        element_handlers[2]["/" + symbol.__name__] = make_symbol_def(symbol)
    #end for
    for symbol in (noverr, xbar) :
        element_handlers[2][symbol.__name__] = handle_common_tag_start
        element_handlers[2]["/" + symbol.__name__] = make_symbol_def(symbol)
    #end for

    def handle_start_element(name, attrs) :
        parse_state["save_content"].append(parse_state["content"])
        parse_state["content"] = []
        if parse_state["nest"] == 0 :
            if name == "carddef" :
                parse_state["nest"] = 1
                parse_state["main_seen"] = True
            else :
                raise RuntimeError \
                  (
                    "unrecognized top-level element \"%s\"." % name
                  )
            #end if
        else :
            handlers = element_handlers.get(parse_state["nest"])
            if handlers != None :
                handler = handlers.get(name)
                if handler != None :
                    if parse_state["nest"] == 2 :
                        parse_state["cur_label"]["content"].append(cdata("".join(parse_state["save_content"][-1])))
                        parse_state["save_content"][-1] = []
                    #end if
                    parse_state["content"] = []
                    parse_state["nest"] += 1
                    handler(name, attrs)
                else :
                    raise RuntimeError \
                      (
                        "unrecognized element \"%s\"." % name
                      )
                #end if
            else :
                raise RuntimeError("unrecognized element nesting")
            #end if
        #end if
    #end handle_start_element

    def handle_end_element(name) :
        parse_state["nest"] -= 1
        if parse_state["nest"] != 0 :
            handler = element_handlers[parse_state["nest"]].get("/" + name)
            if handler != None :
                handler(name)
            #end if
        #end if
        parse_state["content"] = parse_state["save_content"].pop()
    #end handle_end_element

    def handle_cdata(data) :
        parse_state["content"].append(data)
    #end handle_cdata

#begin parse_template
    parser = expat.ParserCreate()
    parser.StartElementHandler = handle_start_element
    parser.EndElementHandler = handle_end_element
    parser.CharacterDataHandler = handle_cdata
    result[0] = {"nrcells" : 1, "center" : {"content" : [cdata("Solid State Software")]}}
    parser.ParseFile(input)
      # can raise expat.ExpatError
    if not parse_state["main_seen"] :
        raise RuntimeError("missing \"carddef\" element")
    #end if
    for i in (2, 3) :
        if result[i] == None :
            result[i] = {"nrcells" : 5} # just draw empty cells
        #end if
    #end for
    return result
#end parse_template

#+
# Mainline
#-

debug_ps = False
template = parse_template(sys.stdin.detach())

if debug_ps :
    args = ("cat",)
else :
    args = \
        (
            "gs", "-q", "-dBATCH", "-dNOPAUSE",
              # -dBATCH needed to turn off prompt (doc says -dNOPAUSE does this, but it
              # lies).
            "-sPAPERSIZE=a4", "-sDEVICE=pngalpha", "-sOutputFile=/dev/stdout",
            "-r%(pixel_density)ux%(pixel_density)u" % {"pixel_density" : 144},
            "/dev/stdin",
              # Side effect of -dBATCH is that gs no longer automatically reads from
              # stdin, need to specify explicit input filenames.
        )
#end if
proc_gs = subprocess.Popen \
  (
    args = args,
    stdin = subprocess.PIPE,
    close_fds = True # make sure no superfluous references to pipes
  )
gs = io.TextIOWrapper(proc_gs.stdin)

card_width = mm(72)
card_height = mm(16)
thumb_margin = mm(2)
label_margin = mm(2)
gs.write \
  (
        "<</PageSize [%(width)u %(height)u] /ImagingBBox null>> setpagedevice\n"
    %
        {
            "width" : card_width,
            "height" : card_height,
        }
  )
gs.write \
  (
    # theory of operation: the Decoding resource named Unicode is a dictionary
    # mapping glyphnames to Unicode character codes. However, multiple glyph names
    # can map to the same character code. I construct the inverse of this mapping,
    # where each character code maps to a dictionary with all the corresponding
    # glyph names as keys (and dummy values). To render a Unicode character,
    # I try all the glyph names corresponding to that character code until I
    # find a match in the CharStrings dictionary of the currentfont.
    "/UnicodeEncode 256 dict def\n" # initial size doesn't matter
    "/DefineCode\n" # glyphname charcode DefineCode -
      # inserts a correspondence between the specified glyph name and character
      # code into UnicodeEncode.
    "  {\n"
    "    UnicodeEncode 1 index known not\n"
    "       { % if\n"
    "        UnicodeEncode 1 index 1 dict put\n" # first glyph name for this character code
    "      }\n"
    "    if\n"
    "    UnicodeEncode exch get exch true put\n"
            # add another glyph name to dict for that character code
            # glyph name is key, value is unimportant
    "  }\n"
    "def\n"
    "/Unicode /Decoding findresource {DefineCode} forall\n"
      # mapping from Unicode character code to possible PostScript glyph names
    "/minus 45 DefineCode\n" # needed for Palatino-Roman
    "\n"
    "/UniShow\n" # chararray UniShow --
      # given an array of Unicode character codes, does a show of the corresponding
      # glyphs in turn. Assumes it's a Type 1 font.
    "  {\n"
    "      {\n"
    "        dup UnicodeEncode exch known\n"
    "          {\n"
    "            UnicodeEncode exch get\n"
    "            /.notdef exch\n" # in case no glyph name found
    "              { % forall\n"
    "                pop\n" # get rid of dummy value
    "                currentfont /CharStrings get 1 index known\n"
    "                  {\n"
    "                    exch pop\n" # get rid of .notdef, leave found key
    "                    exit\n"
    "                  }\n"
    "                  {\n"
    "                    pop\n"
    "                  }\n"
    "                ifelse\n"
    "              }\n"
    "            forall\n"
    "          }\n"
    "          {\n"
    "            pop /.notdef\n"
    "          }\n"
    "        ifelse\n"
    "        glyphshow\n"
    "      }\n"
    "    forall\n"
    "  }\n"
    "def\n"
    "\n"
    "/UniWidth\n" # chararray UniWidth xdelta ydelta
      # given an array of Unicode character codes, returns the width
      # of the complete string.
    "  {\n"
    "   currentpoint 3 2 roll\n" # save currentpoint (assumes there is one!)
    "   clippath pathbbox 4 2 roll pop pop\n"
    "   exch 100 add exch moveto\n" # guaranteed to be outside current clip
    "   currentpoint 3 2 roll UniShow currentpoint\n"
    "   3 2 roll sub 3 1 roll exch sub exch\n"
    "   4 2 roll moveto\n" # restore currentpoint
    "  }\n"
    "def\n"
  )
def glyphify(thestr) :
    """returns a PostScript sequence that constructs an array of glyphs
    from the specified string."""
    return \
        (
            "["
        +
            " ".join("%d" % ord(unich) for unich in thestr)
        +
            "]"
              # yes, this sequence leaks memory
        )
#end glyphify
def UniOp(thestr, Op) :
    """returns a PostScript sequence that uses the UniShow routine
    to render the specified string."""
    return glyphify(thestr) + " " + Op
#end UniOp
def UniShow(thestr) :
    return UniOp(thestr, "UniShow")
#end UniShow
def UniWidth(thestr) :
    return UniOp(thestr, "UniWidth")
#end UniWidth

render_special = \
    { # special actions to modify rendering and width calculation for each tag
        button :
            {
                "widthadjust" : "boxextra 2 mul add",
                "renderbefore" :
                    "currentpoint pop" # save x position
                    " boxextra 2 div 0 rmoveto\n", # add box padding on left
                "renderafter" :
                        "boxextra 2 div 0 rmoveto" # add box padding on right
                        " dup currentpoint pop exch sub" # width of box
                    +
                        " currentpoint exch pop %.2f sub" % (card_height * 0.03)
                    +
                        " exch %.2f rectstroke" % (card_height / 4 * 0.7),
            },
        noverr :
            {
                "widthadjust" :
                    "currentfont dup 0.6 scalefont setfont exch (n) stringwidth pop"
                    " %.2f 0.2 mul add add exch setfont" % basefontsize,
                "renderbefore" : "",
                "renderafter" :
                        "%.2f 0.1 mul 0 rmoveto currentfont dup 0.6 scalefont setfont " % basefontsize
                    +
                        "currentpoint 0 %.2f 0.3 mul rmoveto (n) show" % basefontsize
                    +
                        " moveto currentpoint exch pop 0 %.2f -0.2 mul rmoveto" % basefontsize
                    +
                        " (r) show currentpoint pop %.2f 0.1 mul add exch moveto setfont" % basefontsize,
            },
        subscript :
            {
                "widthadjust" : "%.2f mul" % subsupscale,
                "renderbefore" :
                        "currentfont dup %.2f scalefont setfont" % subsupscale
                    +
                        " 0 %.2f rmoveto" % (suboffset * basefontsize),
                "renderafter" : "0 %.2f rmoveto setfont" % (- suboffset * basefontsize),
            },
        superscript :
            {
                "widthadjust" : "%.2f mul" % subsupscale,
                "renderbefore" :
                        "currentfont dup %.2f scalefont setfont" % subsupscale
                    +
                        " 0 %.2f rmoveto" % (superoffset * basefontsize),
                "renderafter" : "0 %.2f rmoveto setfont" % (- superoffset * basefontsize),
            },
        xbar :
            {
                "widthadjust" : "(x) stringwidth pop add",
                "renderbefore" : "",
                "renderafter" :
                        "currentpoint %.2f 0.65 mul add" % basefontsize
                    +
                        " (x) show currentpoint 4 2 roll"
                        " newpath 2 copy moveto exch pop 2 index exch lineto stroke"
                        " moveto",
            },
    }
for symbol in symbols.values() :
    render_special[symbol] = \
        {
            "widthadjust" :
                        "currentfont exch /%s findfont %.2f scalefont setfont"
                    %
                        (symbolfontname, basefontsize)
                +
                    " %s stringwidth pop add exch setfont" % symbol.psstr,
            "renderbefore" :
                    "currentfont /%s findfont %.2f scalefont setfont %s show"
                %
                    (symbolfontname, basefontsize, symbol.psstr),
            "renderafter" : "setfont",
        }
#end for

gs.write("/%s findfont %.2f scalefont setfont\n" % (fontname, basefontsize))
gs.write("/boxextra (M) stringwidth pop 2 div def\n")
gs.write("/DeviceRGB setcolorspace\n")
corner_radius = mm(1.5)
gs.write("0 0 0 setcolor newpath %.1f 0 moveto\n" % (corner_radius))
gs.write("%.1f 0 rlineto\n" % (card_width - 2 * corner_radius))
gs.write("%.1f %.1f %.1f 270 360 arc\n" % (card_width - corner_radius, corner_radius, corner_radius))
gs.write("0 %.1f rlineto\n" % (card_height - 2 * corner_radius))
gs.write("%.1f %.1f %.1f 0 90 arc\n" % (card_width - corner_radius, card_height - corner_radius, corner_radius))
gs.write("%.1f 0 rlineto\n" % (2 * corner_radius - card_width))
gs.write("%.1f %.1f %.1f 90 180 arc\n" % (corner_radius, card_height - corner_radius, corner_radius))
gs.write("0 %.1f rlineto\n" % (2 * corner_radius - card_height))
gs.write("%.1f %.1f %.1f 180 270 arc\n" % (corner_radius, corner_radius, corner_radius))
gs.write("closepath fill\n")
gs.write("%.3f %.3f %.3f setcolor\n" % tuple(i / 255 for i in (0x95, 0x50, 0x1c)))
gs.write("0.5 setlinewidth\n")
gs.write("newpath 0 %.1f moveto %.1f 0 rlineto stroke\n" % (card_height * 0.75, card_width))
for i in (1, 2) :
    gs.write("newpath 0 %.1f moveto %.1f 0 rlineto stroke\n" % (card_height * i  / 4, card_width - thumb_margin))
#end for
gs.write \
  (
        "newpath %.1f %.1f moveto 0 %.1f rlineto stroke\n"
    %
        (card_width - thumb_margin, card_height * 0.75, - card_height * 0.75)
  )
def rendercell(items, align) :
    if align != "left" :
        gs.write("0\n")
        for item in items :
            gs.write(UniWidth(item.text) + " pop")
            widthadjust = render_special.get(type(item), {}).get("widthadjust")
            if widthadjust != None :
                gs.write(" " + widthadjust)
            #end if
            gs.write(" add\n")
        #end for
        gs.write("-%.1f mul 0 rmoveto\n" % {"center" : 0.5, "right" : 1.0}[align])
    #end if
    for item in items :
        special = render_special.get(type(item), {})
        renderbefore = special.get("renderbefore")
        renderafter = special.get("renderafter")
        if renderbefore != None :
            gs.write(renderbefore + "\n")
        #end if
        gs.write(UniShow(item.text) + "\n")
        if renderafter != None :
            gs.write(renderafter + "\n")
        #end if
    #end for
#end rendercell
for i in range(0, 4) :
    if template[i] != None :
        row = template[i]
        if row["nrcells"] > 1 :
            for col in range(1, row["nrcells"] + 1) :
                gs.write("%% (row, col) = (%d, %d)\n" % (i, col)) # debug
                gs.write \
                  (
                        "newpath %.1f %.1f moveto\n"
                    %
                        (
                            (card_width - thumb_margin) * col / row["nrcells"],
                            card_height * (4 - i) / 4,
                        )
                  )
                gs.write("0 -%.1f rlineto stroke\n" % (card_height * 0.25))
                if col in row :
                    gs.write \
                      (
                            "newpath %.1f %.1f moveto "
                        %
                            (
                                    label_margin
                                +
                                        (card_width - thumb_margin)
                                    /
                                        5
                                    *
                                        (col - 0.65),
                                card_height * (4 - i - 0.75) / 4,
                            )
                      )
                    rendercell(row[col]["content"], "center")
                #end if
            #end for
        else :
            for align in ("left", "center", "right") :
                if align in row :
                    gs.write("%% (row, align) = (%d, %s)\n" % (i, align)) # debug
                    gs.write \
                      (
                            "newpath %.1f %.1f moveto "
                        %
                            (
                                    label_margin
                                +
                                        (card_width - thumb_margin - 2 * label_margin)
                                    *
                                        {"left" : 0.0, "center" : 0.5, "right" : 1.0}[align],
                                card_height * (4 - i - 0.75) / 4,
                            )
                      )
                    rendercell(row[align]["content"], align)
                #end if
            #end for
        #end if
    #end if
#end for
gs.write("showpage\n")

gs.close()
proc_gs.wait()
